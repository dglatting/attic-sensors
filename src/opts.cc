/* -*- c++ -*- */

/*
 * Copyright (c) 2018,2019 Dennis Glatting
 * Copyright (c) 2018 atfCYBER. All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE. 
 *
 *
 * This file holds declarations and routines relevant to options
 * parsing.
 *
 *
 * Boost is a large contributor to this file's ugliness. Boost
 * generates a lot of code compared to a getopt() solution.
 *
 * Rather than going through the log library, generally this code
 * uses std::cerr for error statement printing because these
 * routines are executed at a time when the application is single
 * threaded.
 *
 *
 * $Log: opts.cc,v $
 * Revision 1.26  2019/10/07 03:42:36  root
 * Shortened the function quoteStr().
 *
 * Revision 1.25  2019/10/05 04:08:20  root
 * Added decision logic for foreground/background and logging.
 *
 * Revision 1.24  2019/10/01 05:48:49  root
 * Added daemon flag. Cleaned up Help message.
 *
 * Revision 1.23  2019/09/26 04:48:02  root
 * Removed __ signed/unsigned integer decls.
 *
 * Revision 1.22  2019/09/17 03:00:33  root
 * Minor change to implement a c++17 idiom.
 *
 * Revision 1.21  2019/09/04 04:23:47  root
 * Added MIT copyright notice.
 *
 * Revision 1.20  2019/08/27 07:09:13  root
 * It crashes the kernel, so that's nice.
 *
 * Revision 1.19  2019/08/27 01:01:34  root
 * Adding additional utilities to source.
 *
 * Revision 1.18  2018/08/21 21:47:30  root
 * Created/implemented a bunch of utility subroutines to standardize 
 * print output and reduce memory errors.
 *
 * Revision 1.17  2018/08/20 09:18:41  root
 * Logging subsysten to reduce the boost bloat.
 *
 * Revision 1.16  2018/08/17 08:45:46  root
 * Added new client option to limit connections for debugging.
 *
 * Revision 1.15  2018/08/16 10:40:20  root
 * Many changes.
 *
 * Revision 1.14  2018/07/04 08:44:34  root
 * Forced check-in of a working branch of code before the next round
 * of revisions. This version ran for 24 hours across a 3x3 node WiFi
 * network, consuming ~12Mb/sec of bandwidth and showing no apparent
 * memory of leakages. The next version of this code is to organise
 * key from tiered arrays into sets with individual keys (elements)
 * belonging to a set, resulting in sets of sets. The "array" and
 * "name" identifiers will be respectably replaced with "set" and
 * "elem"(element). Code will be added to form intersections of
 * sets. Code will also be added (i.e., SQLite) to store elements
 * (keys) in a database where should be more manageable in standard
 * form.
 *
 * Revision 1.13  2018/07/02 02:57:48  root
 * Client and server are now talking TCP/TLS although some more
 * debugging is necessary.
 *
 * Revision 1.12  2018/06/27 17:49:47  root
 * In c++ threads cannot create threads. That means redesign of the
 * server.
 *
 * Revision 1.11  2018/06/21 06:00:10  root
 * I believe I have finally fixed the gethostbyname2_r() problems
 * however not all of the failure cases have been exercised. 
 *
 * I removed the static from the ident structure declaration so its
 * content can be output by main().
 *
 * Revision 1.10  2018/06/20 04:16:33  root
 * Checking in changes before next release.
 *
 * Revision 1.9  2018/06/20 04:09:20  root
 * Debugged a weird problem in _parse_remote() where the matched token
 * was getting clobbered and regex failing.
 *
 * I coded gethostbyname2_() to the man page but its implementation
 * indicated important differences.
 *
 * Revision 1.8  2018/06/16 00:56:49  root
 * Added atfCYBER copyright.
 *
 * Revision 1.7  2018/06/16 00:43:23  root
 * Fixed warnings generated by clang++ 6.0.
 *
 * Revision 1.6  2018/06/15 07:31:30  root
 * The default logging level was set too restrictive.
 *
 * Revision 1.5  2018/06/15 07:23:19  root
 * The client and server now talk to each other.
 *
 * Revision 1.4  2018/06/12 05:48:41  root
 * Everything compiles and links. Now on to actual client/server
 * testing.  Will enable selection between IPv6/IPv4 in future.  Will
 * optimize threading in server in future.
 *
 * Revision 1.3  2018/06/11 03:49:32  root
 * Added threading to the client and expanded options.
 *
 * Revision 1.2  2018/06/06 01:53:45  root
 * The client code compiles and links. Archiving before debug.
 *
 * Revision 1.1  2018/06/05 18:14:31  root
 * Initial revision
 *
 */

extern "C" {

#include <getopt.h>
#include <limits.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <syslog.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/stat.h>

}

#include <algorithm>
#include <fstream>
#include <iostream>
#include <map>
#include <regex>
#include <sstream>
#include <string>
#include <thread>
#include <tuple>
#include <vector>

#include "log.h"
#include "opts.h"
#include "util.h"


extern const
std::vector< std::string > opts_ident {
  _OPT_H_ID, "$Id: opts.cc,v 1.26 2019/10/07 03:42:36 root Exp root $"
};


// Logging level and where to send it.

int logging_level = LOG_INFO;
std::string logDev = "stdout";

// Whether or not to become a daemon.

bool doDaemon = true;


static const std::vector< std::string >
toks( const std::string& s ) {

  static const std::regex sep( "\\s*[,]\\s*" );

  std::sregex_token_iterator pos( s.cbegin(), s.cend(), sep, -1 ), end;
  std::vector< std::string>  r;

  while( pos != end )
    r.push_back( *pos++ );

  return r;
}


const
std::string tok( const std::string& s ) {

  const std::vector< std::string > r = toks( s );

  assert( r.size());

  if( r[ 0 ].length())
    return r[ 0 ];
  else
    return std::string( "-" + r[ 1 ]);

}


const std::string
min_max( size_t min, size_t max) {

  std::stringstream s;

  s << min << "," << max;

  return s.str();
}


// Parse argv and set variables. Return false is there was a problem.

bool
parse_opts( int argc, char** argv ) {

  bool argsOk = true;
  
  bool doHelp  = false,
       doDebug = false,
       doVerb  = false,
       doLog   = false;
  int  ch;

  std::string clLogDev { "default" };
  
  while(( ch = ::getopt( argc, argv, "dhvfl:" )) != -1 ) {

    switch( ch ) {
      
    case 'd':
      doDebug = true;
      break;

    case 'f':
      doDaemon = false;
      break;
      
    case 'h':
      doHelp = true;
      break;

    case 'l':
      doLog = true;
      if( ::strcasecmp( optarg, "stdout" ) == 0 )
	clLogDev = "stdout";
      else
	if( ::strcasecmp( optarg, "syslog" ) == 0 )
	  clLogDev = "syslog";
	else {
	  std::cerr << "Unsupported log target " << quote( optarg )
		    << std::endl;
	  usage();
	  exit( -1 );
	}
      break;
      
    case 'v':
      doVerb = true;
      break;
      
    default:
      _LOG_ERR(( "Unknown option ", quote( char( ch ))));
      
    }
  }

  // Take action(s) based on command line arguments.
  
  if( doDebug )
    logging_level = LOG_DEBUG;
  if( doVerb )
    logging_level = LOG_VERB;

  // Logging seems complex but it's a simple decision tree that can be
  // overridden from the command line.
  //
  // First decision:
  //   Foreground or background mode?
  // Second decision:
  //   If foreground then
  //    log to stdout
  //   Else /* i.e., background */
  //    log to syslog
  // Third decision:
  //   Override log output by command line.
  
  if( doLog ) {
    if( clLogDev == "default" ) {
      if( doDaemon )
	logDev = "syslog";
      else
	logDev = "stdout";
    } else {
      if(( clLogDev == "stdout" ) || ( clLogDev == "syslog" ))
	logDev = clLogDev;
      else
	_LOG_ABORT(( "Impossible state" ));
    }
  } else
    if( doDaemon )
      logDev = "syslog";
    else
      logDev = "stdout";
  
  // Can I take the easy way out?
  
  if( doHelp ) {
    usage();
    exit( 0 );
  }

  if( _IS_LOG_DEBUG ) {

    // Print out stored arguments.

    std::cout << "Log level: " << logging_level               << std::endl
	      << ( doVerb ? " (verbose)" : "" )               << std::endl
	      << "Help:      " << ( doHelp ? "Yes" : "No" )   << std::endl
	      << "Daemon:    " << ( doDaemon ? "Yes" : "No" ) << std::endl
	      << "Log:       " << logDev                      << std::endl;
      
  }
  
  return argsOk;
}


void
usage( void ) {
  std::cerr << "usage: "                                       << std::endl
	    << " -d   Debug mode."                             << std::endl
	    << " -f   Run in foreground (i.e., no daemon)"     << std::endl
	    << " -h   This message"                            << std::endl
	    << " -v   Verbose mode (Warning: VERY verbose)"    << std::endl
	    << " -l   Log to \"syslog\" or \"stdout\""         << std::endl
	    << "      stdout default for -f, otherwise syslog" << std::endl
	    << std::endl;  
}


//  LocalWords:  DTLS LSA AES NUM errno gethostbyname TCP TLS SSL ini
//  LocalWords:  SQLite argv getopt DNS IPv isValid localhost URIs
//  LocalWords:  URI
